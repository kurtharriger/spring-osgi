<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
                 "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

  <chapter id="service-registry">
    <title>The Service Registry</title>

    <para>The OSGi service registry enables a bundle to publish objects to a
    shared registry, advertised via a given set of Java interfaces. Published
    services also have service properties associated with them in the
    registry.</para>

    <para>Spring Dynamic Modules provides an <literal>osgi</literal> namespace for Spring (see
    <xref linkend="appendix-schema"/>) that can be used to export 
    Spring beans as OSGi services, and
    to define references to services obtained via the service registry. The
    namespace elements may be used nested inside another top-level namespace
    (typically the Spring <literal>beans</literal> namespace), or within the top-level
    <literal>osgi</literal> element.</para>

    <para>The following example shows the use of the <literal>osgi</literal>
    namespace within the familiar Spring beans element:</para>

	<programlistingco>
	   <areaspec>
	   	  <area id="service-registry.xml.ns.default.beans" coords="2"/>
          <area id="service-registry.xml.ns.osgi" coords="4"/>
          <area id="service-registry.xml.ns.beans.25" coords="6"/>
          <area id="service-registry.xml.osgi.service" coords="11"/>
       </areaspec>
       <programlisting><![CDATA[<xml version="1.0" encoding="UTF-8"?>;
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:osgi="http://www.springframework.org/schema/osgi"
   xsi:schemaLocation="http://www.springframework.org/schema/beans   
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/osgi  
       http://www.springframework.org/schema/osgi/spring-osgi-1.0.xsd">

    <!-- use the OSGi namespace elements qualified with 'osgi:' -->
    <osgi:service id="simpleServiceOsgi" ref="simpleService"
      interface="org.xyz.MyService" />

</beans>]]></programlisting>
       <calloutlist>
         <callout arearefs="service-registry.xml.ns.default.beans">
            <para>Use Spring Framework <literal>beans</literal> schema as the default namespace.
            </para>
         </callout>
       
         <callout arearefs="service-registry.xml.ns.osgi">
            <para>Import Spring Dynamic Modules schema and associate a prefix with its namespace (<literal>osgi</literal> in this example).
            </para>
         </callout>
         <callout arearefs="service-registry.xml.ns.beans.25">
         	<para>Make sure to import Spring beans schema version <emphasis>2.5</emphasis>.</para>
         </callout>
         <callout arearefs="service-registry.xml.osgi.service">
         	<para>Use Spring Dynamic Modules elements using the declared namespace prefix (in this example <literal>osgi</literal>).</para>
         </callout>
       </calloutlist>
	</programlistingco>

    <para>Using the OSGi namespace as a top-level namespace the same service
    would be declared as follows:</para>

    <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/osgi"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:beans="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/osgi  
       http://www.springframework.org/schema/osgi/spring-osgi-1.0.xsd
       http://www.springframework.org/schema/beans   
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">

  <!-- use the OSGi namespace elements directly -->
  <service id="simpleServiceOsgi" ref="simpleService"
       interface="org.xyz.MyService" />

</beans:beans>]]></programlisting>

    <para>Using the OSGi namespace as a top-level namespace is particularly
    convenient when following the recommendation of section <link linkend="app-deploy:headers">4.1</link> to use a
    dedicated configuration file for all OSGi-related declarations.</para>

    <section id="service-registry:export">
      <title>Exporting a Spring bean as an OSGi service</title>

      <para>The <literal>service</literal> element is used to define a bean
      representing an exported OSGi service. At a minimum you must specify the
      bean to be exported, and the <emphasis>service interface</emphasis> that
      the service offers.</para>

      <para>For example, the declaration</para>

      <programlisting><![CDATA[<service ref="beanToPublish" interface="com.xyz.MessageService"/>]]></programlisting>

      <para>exports the bean with name <literal>beanToPublish</literal> with
      interface <literal>com.xyz.MessageService</literal>. The published
      service will have a service property with the name
      <literal>org.springframework.osgi.bean.name</literal> set to the name of
      the target bean being registered (<literal>beanToPublish</literal> in
      this case).</para>

      <para>The bean <emphasis>defined</emphasis> by the
      <literal>service</literal> element is of type
      <interfacename>org.osgi.framework.ServiceRegistration</interfacename> and is the
      <interfacename>ServiceRegistration</interfacename> object resulting from registering
      the exported bean with the OSGi service registry. By giving this bean an
      id you can inject a reference to the
      <interfacename>ServiceRegistration</interfacename> object into other beans if
      needed. For example:</para>

      <programlisting><![CDATA[<service id="myServiceRegistration" ref="beanToPublish"
    interface="com.xyz.MessageService"/>]]></programlisting>

      <para>As an alternative to exporting a named bean, the bean to be
      exported to the service registry may be defined as an anonymous inner
      bean of the service element. Typically the top-level namespace would be
      the <literal>beans</literal> namespace when using this style:</para>

      <programlisting><![CDATA[<osgi:service interface="com.xyz.MessageService">
  <bean class="SomeClass">
     ...
  </bean>
</osgi:service>]]></programlisting>

      <para>If the bean to be exported implements the
      <interfacename>org.osgi.framework.ServiceFactory</interfacename> interface then the
      <interfacename>ServiceFactory</interfacename> contract is honored as per section 5.6
      of the OSGi Service Platform Core Specification. As an alternative to
      implementing this OSGi API, Spring Dynamic Modules introduces a new bean
      scope, the <literal>bundle</literal> scope. When a bean with bundle
      scope is exported as an OSGi service then one instance of the bean will
      be created for each unique client (service importer) bundle that
      obtains a reference to it through the OSGi service registry. When a
      service importing bundle is stopped, the bean instance associated with
      it is disposed. To declare a bean with <literal>bundle</literal> scope
      simply use the <literal>scope</literal> attribute of the
      <literal>bean</literal> element:</para>

      <programlisting><![CDATA[<osgi:service ref="beanToBeExported" interface="com.xyz.MessageService"/>

<bean id="beanToBeExported" scope="bundle" class="com.xyz.MessageServiceImpl"/>]]></programlisting>

      <section id="service-registry:export:intfs">
        <title>Controlling the set of advertised service interfaces for
        an exported service</title>

        <para>The OSGi Service Platform Core Specification defines the term
        <emphasis>service interface</emphasis> to represent the specification
        of a service's public methods. Typically this will be a Java
        interface, but the specification also supports registering service
        objects under a class name, so the phrase <emphasis>service
        interface</emphasis> can be interpreted as referring to either an
        interface or a class.</para>

        <para>There are several options for specifying the service
        interface(s) under which the exported service is registered. The
        simplest mechanism, shown above, is to use the
        <literal>interface</literal> attribute to specify a fully-qualified
        interface name. To register a service under multiple interfaces the
        nested <literal>interfaces</literal> element can be used in place of
        the <literal>interface</literal> attribute.</para>

        <programlisting><![CDATA[<osgi:service ref="beanToBeExported">
  <osgi:interfaces>
     <value>com.xyz.MessageService</value>
     <value>com.xyz.MarkerInterface</value>
  </osgi:interfaces>
</osgi:service>]]></programlisting>

		<para>It is illegal to use both <literal>interface</literal> attribute and
		<literal>interfaces</literal> element at the same time - use only one of them.
		</para>
	  
	  <section id="service-registry:export:auto-export">
	    <title>Detecting the advertised interfaces at runtime</title>
		<sidebar>
			<title>Hierarchy visibility</title>
			
        	<para>Note that when using <literal>auto-export</literal>, only types visible to the
        	bundle exporting the service are registered. For example, a
        	super-interface <literal>SI</literal> would not be exported as a
        	supported service interface even when using
        	<literal>auto-export="interfaces"</literal> if <literal>SI</literal>
        	was not on the exporting bundle's classpath.</para>
        	
        	<para>Even if exported service class does implement <literal>SI</literal> transitively based
        	on its parent, if the declaring bundle doesn't import the 
        	interface, the class is unknown to the exported service. While this 
        	might seem counter intuitive, it is actually one of the most powerful features of OSGi
        	which give the bundle authors control over the class visibility and path.
        	</para>
        	
        	<para>Please see the FAQ for a more detailed explanation.</para>
        </sidebar>

        <para>Using the <literal>auto-export</literal> attribute you can avoid
        the need to explicitly declare the service interfaces at all by analyzing the
        object class hierarchy and its interfaces.</para>
        <para> 
        The <literal>auto-export</literal> attribute can have one of four
        values:</para>

        <itemizedlist>
          <listitem>
            <para><literal>disabled</literal> : the default value; no auto-detected of service
            interfaces is undertaken and the <literal>interface</literal>
            attribute or <literal>interfaces</literal> element must be used
            instead.</para>
          </listitem>

          <listitem>
            <para><literal>interfaces</literal> : the service will be registered using all of the
            Java interface types implemented by the bean to be exported</para>
          </listitem>

          <listitem>
            <para><literal>class-hierarchy</literal> : the service will be registered using the
            exported bean's implementation type and super-types</para>
          </listitem>

          <listitem>
            <para><literal>all-classes</literal> : the service will be registered using the exported
            bean's implementation type and super-types plus all interfaces
            implemented by the bean.</para>
          </listitem>
        </itemizedlist>

		<para>
		<literal>auto-export</literal> and <literal>interface(s)</literal> option are not exclusive; both
		can be used at the same time for fine grained control over the advertised interfaces if there is such
		a need. However, the former	option should be enough for most cases. 
		</para>
        <para>For example, to automatically register a bean under all of the
        interfaces that it supports you would declare:</para>

        <programlisting><![CDATA[<service ref="beanToBeExported" auto-export="interfaces"/>]]></programlisting>

        <para>Given the interface hierarchy:</para>

        <programlisting><![CDATA[public interface SuperInterface {}

public interface SubInterface extends SuperInterface {}]]></programlisting>

        <para>then a service registered as supporting the
        <literal>SubInterface</literal> interface is <emphasis>not</emphasis>
        considered a match in OSGi when a lookup is done for services
        supporting the <literal>SuperInterface</literal> interface. For this
        reason it is a best practice to export all interfaces supported by the
        service being registered explicitly, using either the
        <literal>interfaces</literal> element or
        <literal>auto-export="interfaces"</literal>.</para>

      </section>
      </section>
      

      <section id="service-registry:export:props">
        <title>Controlling the set of advertised properties for an
        exported service</title>

        <para>As previously described, an exported service is always
        registered with the service property
        <literal>org.springframework.osgi.bean.name</literal> set to the name
        of the bean being exported. Additional service properties can be
        specified using the nested <literal>service-properties</literal>
        element. The <literal>service-properties</literal> element contains
        key-value pairs to be included in the advertised properties of the
        service. The key must be a string value, and the value must be a type
        recognized by OSGi Filters. See section 5.5 of the OSGi Service
        Platform Core Specification for details of how property values are
        matched against filter expressions.</para>

        <para>The <literal>service-properties</literal> element must contain
        at least one nested <literal>entry</literal> element from the Spring
        beans namespace. For example:</para>

        <programlisting><![CDATA[<service ref="beanToBeExported" interface="com.xyz.MyServiceInterface">
  <service-properties>
    <beans:entry key="myOtherKey" value="aStringValue"/>
    <beans:entry key="aThirdKey" value-ref="beanToExposeAsProperty"/>
  <service-properties>
</service>]]></programlisting>

        <para>The Spring Dynamic Modules roadmap includes support for
        exporting properties registered in the OSGi Configuration
        Administration service as properties of the registered service. See
        <link linkend="appendix-roadmap">this</link> appendix for more details.</para>
        
      </section>

      <section id="service-registry:export:depends-on">
        <title>The depends-on attribute</title>

        <para>Spring will manage explicit dependencies of a service element,
        ensuring for example that the bean to be exported as a service is
        fully constructed and configured before exporting it. If a service has
        implicit dependencies on other components (including other service
        elements) that must be fully initialized before the service can be
        exported, then the optional <literal>depends-on</literal> attribute
        can be used to express these dependencies.</para>

        <programlisting><![CDATA[<service ref="beanToBeExported" interface="com.xyz.MyServiceInterface"
     depends-on="myOtherComponent"/>]]></programlisting>
      </section>
      
      <section id="service-registry:export:ccl">
        <title>The context-class-loader attribute</title>

        <para>The OSGi Service Platform Core Specification (most current
        version is 4.1 at time of writing) does not specify what types and
        resources are visible through the context class loader when an
        operation is invoked on a service obtained via the service registry.
        Since some services may use libraries that make certain assumptions
        about the context class loader, Spring Dynamic Modules enables you to
        explicitly control the context class loader during service execution.
        This is achieved using the option
        <literal>context-class-loader</literal> attribute of the service
        element.</para>

        <para>The permissible values for the
        <literal>context-class-loader</literal> attribute are
        <literal>unmanaged</literal> (the default) and
        <literal>service-provider</literal>. When the
        <literal>service-provider</literal> value is specified, Spring Dynamic
        Modules ensures that the context class loader can see all of the
        resources on the class path of the bundle exporting the service.</para>
      </section>
      
      <section id="service-registry:export:ranking">
        <title>The ranking attribute</title>

        <para>When registering a service with the service registry, you may
        optionally specify a service ranking (see section 5.2.5 of the OSGi
        Service Platform Core Specification). When a bundle looks up a service
        in the service registry, given two or more matching services the one
        with the highest ranking will be returned. The default ranking value
        is zero. To explicitly specify a ranking value for the registered
        service, use the optional <literal>ranking</literal> attribute.</para>

        <programlisting><![CDATA[<service ref="beanToBeExported" interface="com.xyz.MyServiceInterface"
  ranking="9"/>]]></programlisting>
      </section>


      <section id="service-registry:export:service:attributes">
       <para>
       As a summary, the following table lists the attributes names, possible values and
       a short description for each of them.
       </para>
       <table id="service-export-options" pgwide="1">
          <title>OSGi &lt;service&gt; attributes</title>
          <tgroup cols="3">
            <colspec align="center" />
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Values</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>interface</entry>
                <entry>fully qualified class name (such as <literal>java.lang.Thread</literal>)</entry>
                <entry>the fully qualified name of the class under which the object will be exported</entry>
              </row>
              <row>
                <entry>ref</entry>
                <entry>any bean name</entry>
                <entry>Reference to the named bean to be exported as a service in the service registry.</entry>
              </row>
              <row>
                <entry>context-class-loader</entry>
                <entry>unmanaged | service-provider</entry>
                <entry>Defines how the context class loader will be managed when an operation is invoked on the 
                exported service. The default value is <literal>unmanaged</literal> which means that no management of 
                the context class loader is attempted. A value of <literal>service-provider</literal> guarantees that
                the context class loader will have visibility of all the resources on the class path of 
                bundle exporting the service.</entry>
              </row>
              <row>
                <entry>auto-export</entry>
                <entry>disabled | interfaces | class-hierarchy | all-classes</entry>
                <entry>Enables Spring to automatically manage the set of service interfaces advertised for the
				service. By default this facility is <literal>disabled</literal>. A value of <literal>interfaces</literal> advertises all 
                of the Java interfaces supported by the exported service. A value of <literal>class-hierarchy</literal> 
                advertises all the Java classes in the hierarchy of the exported service. A value of 
                <literal>all-classes</literal> advertises all Java interfaces and classes.</entry>
              </row>
              <row>
                <entry>ranking</entry>
                <entry>any integer value</entry>
                <entry>Specify the service ranking to be used when advertising the service. Default value is 0.</entry>
              </row>
              
            </tbody>
          </tgroup>
      </table>        
      
      </section>

      <section id="service-registry:export:lifecycle">
        <title>Service registration and unregistration lifecycle</title>

        <para>The service defined by a <literal>service</literal> element is
        registered with the OSGi service registry when the application context
        is first created. It will be unregistered automatically when the
        bundle is stopped and the application context is disposed.</para>


        <para>If you need to take some action when a service is unregistered
        because its dependencies are not satisfied (or when it is registered),
        then you can define a listener bean using the nested
        <literal>registration-listener</literal> element.</para>

        <para>The declaration of a registration listener must use either the
        <literal>ref</literal> attribute to refer to a top-level bean
        definition, or declare an anonymous listener bean inline. For
        example:</para>

        <programlisting><![CDATA[<!-- example service declaration with two listeners -->

<service ref="beanToBeExported" interface="SomeInterface">
  <registration-listener ref="myListener"
    registration-method="serviceRegistered"
    unregistration-method="serviceUnregistered"/>
  <registration-listener
     registration-method="register"
     unregistration-method="unregister">
     <bean class="SomeListenerClass"/>
  </registration-listener>
</service>]]></programlisting>

        <para>The optional <literal>registration-method</literal> and
        <literal>unregistration-method</literal> attributes specify the names
        of the methods defined on the listener bean that are to be invoked
        during registration and unregistration. A registration callback method
        must have a signature matching one of the following formats:</para>

        <programlisting><![CDATA[public void anyMethodName(ServiceType serviceInstance, Map serviceProperties);]]></programlisting>
        
        <programlisting><![CDATA[public void anyMethodName(ServiceType serviceInstance, Dictionary serviceProperties);]]></programlisting>

        <para>where <literal>ServiceType</literal> can be any type compatible
        with the exported service interface of the service.</para>

        <para>An unregistration callback method must have a signature of the
        form</para>

        <programlisting><![CDATA[public void anyMethodName(ServiceType serviceInstance, Map serviceProperties);]]></programlisting>
        
        <programlisting><![CDATA[public void anyMethodName(ServiceType serviceInstance, Dictionary serviceProperties);]]></programlisting>

        <para>where <literal>ServiceType</literal> can be any type compatible
        with the exported service interface of the service.</para>

        <para>The register callback is invoked when the service is initially
        registered at startup, and whenever it is subsequently re-registered.
        The unregister callback is invoked during the service unregistration process, 
        no matter the cause (such as the owning bundle stopping).</para>
        
        <para>Spring-DM will use the declared <literal>ServiceType</literal> argument type
        and invoke the registration/unregistration method only when a service of a compatible type
        will be registered/unregistered.</para>
        
        <para><literal>serviceProperties</literal> represents a map holding all the properties
        of the registered/unregistered service. To preserve compatibility with the OSGi specification
        this argument can be cast, if needed, to a <literal>java.util.Dictionary</literal>.</para>
        
        <section id="service-registry:export:lifecycle:interface">
        <title>Using <interfacename>OsgiServiceRegistrationListener</interfacename> interface</title>
        <para>
        While we discourage, it is possible to implement a Spring-DM specific interface, namely 
        <interfacename>org.springframework.osgi.service.exporter.OsgiServiceRegistrationListener</interfacename> which avoids the need
        to declare the <literal>registration-method</literal> and <literal>unregistration-method</literal>.
        However, by implementing <interfacename>OsgiServiceRegistrationListener</interfacename>, your code
        becomes Spring-DM aware (which goes against the POJO philosophy).
        </para>
        
        <para>It is possible for a listener to implement <interfacename>OsgiServiceRegistrationListener</interfacename> interface and
        declare custom methods. In this case, the Spring-DM interface methods will be called first, followed by the custom methods.
        </para>
        </section>
      </section>
    </section>

    <section id="service-registry:refs">
      <title>Defining references to OSGi services</title>

      <para>Spring Dynamic Modules supports the declaration of beans that
      represent services accessed via the OSGi Service Registry. In this
      manner references to OSGi services can be injected into application
      components. The service lookup is made using the service interface type
      that the service is required to support, plus an optional filter
      expression that matches against the service properties published in the
      registry.</para>

      <para>For some scenarios, a single matching service that meets the
      application requirements is all that is needed. The
      <literal>reference</literal> element defines a reference to a single
      service that meets the required specification. In other scenarios,
      especially when using the OSGi <ulink
      url="http://www.osgi.org/documents/osgi_technology/whiteboard.pdf">whiteboard
      pattern</ulink>, references to <emphasis>all available</emphasis>
      matching services are required. Spring Dynamic Modules supports the
      management of this set of references as a <interfacename>List</interfacename>,
      <interfacename>Set</interfacename> collection.</para>

      <section id="service-registry:refs:singular">
        <title>Referencing an individual service</title>

        <para>The <literal>reference</literal> element is used to define a
        reference to a service in the service registry. The
        <literal>interface</literal> attribute identifies the service
        interface that a matching service must implement. For example, the
        following declaration creates a bean
        <literal>messageService</literal>, which is backed by the service
        returned from the service registry when querying it for a service
        offering the <interfacename>MessageService</interfacename> interface.</para>

        <programlisting><![CDATA[<reference id="messageService" interface="com.xyz.MessageService"/>]]></programlisting>

        <para>If there are several services in the service registry then the
        service returned is the service that would be returned by a call to
        <literal>BundleContext.getServiceReference</literal>. This means that
        the service with the highest ranking will be returned, or if there is
        a tie in ranking, the service with the lowest service id (the service
        registered first with the framework) is returned (please see Section 5
        from the OSGi spec for more information on the service selection algorithm).</para>

        <para>The bean defined by the reference element implements all of the
        advertised interfaces of the service that are visible to the bundle.
        If the registered service interfaces include Java class types (as
        opposed to interface types) then support for these types is subject to
        the restrictions of Spring's AOP implementation (see the Spring
        Reference Guide). In short, <literal>cglib</literal> library must be
        available, and <literal>final</literal> methods are not
        supported.</para>

		<section id="service-registry:refs:singular:property-editor">
		<title>Getting a hold of the managed service service reference</title>
        
        <para>Spring-DM can automatically convert a managed OSGi service to 
        service reference. That is, if the property into which a reference bean 
        is to be injected, has type <interfacename>ServiceReference</interfacename> (instead of the service
        interface supported by the reference), then the managed OSGi
        <interfacename>ServiceReference</interfacename> for the service will be injected
        in place of the service itself:</para>

		<programlisting><![CDATA[
public class BeanWithServiceReference {
	private ServiceReference serviceReference;
	private SomeService service;
			
	// getters/setters ommitted
}]]></programlisting>
		
		<programlisting><![CDATA[
<reference id="service" interface="com.xyz.SomeService"/>
		
<bean id="someBean" class="BeanWithServiceReference">
  <!-- the managed service is converted into a ServiceReference -->
  <property name="serviceReference" ref="service"/> 
  <!-- the managed service is injected as is -->
  <property name="service" ref="service"/>
</bean>]]></programlisting>
		
		<note>
		The injected <interfacename>ServiceReference</interfacename> is managed by Spring-DM and will change
		at the same time as the referenced backing OSGi service instance.  
		</note>
		</section>
		
        <section id="service-registry:refs:singular:filter">
          <title>The <literal>filter</literal> attribute</title>

          <para>The optional <literal>filter</literal> attribute can be used
          to specify an OSGi filter expression and constrains the service
          registry lookup to only those services that match the given
          filter.</para>

          <para>For example:</para>

          <programlisting><![CDATA[<reference id="asyncMessageService" interface="com.xyz.MessageService"
  filter="(asynchronous-delivery=true)"/>]]></programlisting>
  
  		  <para>will match only OSGi services that advertise <interfacename>MessageService</interfacename>
  		  interface and have the property named <literal>asynchronous-delivery</literal> set to value <literal>true</literal>.
  		  </para>
        </section>

        <section id="service-registry:refs:singular:bean-name">
          <title>The <literal>bean-name</literal> attribute</title>

          <para>The <literal>bean-name</literal> attribute is a convenient
          short-cut for specifying a filter expression that matches on the
          <literal>bean-name</literal> property automatically set when exporting a bean using the
          <literal>service</literal> element (see <xref linkend="service-registry:export"/>).</para>

          <para>For example:</para>

          <programlisting><![CDATA[<reference id="messageService" interface="com.xyz.MessageService"
   bean-name="defaultMessageService"/>]]></programlisting>
   
   		  <para>will match only OSGi services that advertise <interfacename>MessageService</interfacename>
   		  interface and have the property named <literal>org.springframework.osgi.bean.name</literal> set
   		  to value <literal>defaultMessageService</literal>. In short, this means finding all Spring-DM exported
   		  beans that implement interface <interfacename>MessageService</interfacename> and are named
   		  <literal>defaultMessageService</literal>.</para>
   		  
        </section>

        <section id="service-registry:refs:singular:cardinality">
          <title>The <literal>cardinality</literal> attribute</title>

		  <sidebar>
		    <title><![CDATA[Nested <reference> declarations]]></title>
		    <para>In order for Spring-DM to detect mandatory dependencies, any
		    <ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-inner-beans">nested/inner</ulink>
		    reference declaration will be transformed into top-level
		    one with a generated name.</para>
		  </sidebar>

          <para>The <literal>cardinality</literal> attribute is used to
          specify whether or not a matching service is required at all times.
          A cardinality value of <literal>1..1</literal> (the default)
          indicates that a matching service must always be available. A
          cardinality value of <literal>0..1</literal> indicates that a
          matching service is not required at all times (see section 4.2.1.6
          for more details). A <literal>reference</literal> with cardinality
          <literal>1..1</literal> is also known as a
          <emphasis>mandatory</emphasis> service reference and, by default,
          application context creation is deferred until the reference is
          satisfied.</para>

          <note>It is an error to declare a mandatory reference to a
          service that is also exported by the same bundle, this behavior can
          cause application context creation to fail through either deadlock
          or timeout.</note>
        </section>

        <section id="service-registry:refs:singular:depends-on">
          <title>The depends-on attribute</title>

          <para>The <literal>depends-on</literal> attribute is used to specify
          that the service reference should not be looked up in the service
          registry until the named dependent bean has been
          instantiated.</para>
        </section>

        <section id="service-registry:refs:singular:tccl">
          <title>The context-class-loader attribute</title>

          <para>The OSGi Service Platform Core Specification (most current
          version is 4.1 at time of writing) does not specify what types and
          resources are visible through the context class loader when an
          operation is invoked on a service obtained via the service registry.
          Since some services may use libraries that make certain assumptions
          about the context class loader, Spring Dynamic Modules enables you
          to explicitly control the context class loader during service
          invocation. This is achieved using the option
          <literal>context-class-loader</literal> attribute of the
          <literal>reference</literal> element.</para>

		  <sidebar>
		    <title>context class loader management on the importer and exporter</title>
		    <para>
		      Spring-DM has the ability to do context class loader management on both
		      the importer and exporter side. Normally, if Spring-DM works on both sides,
		      only one side should have this feature enabled. However, if both sides 
		      (importer and exporter) take advantage of this capability, the last
		      entity in the call chain will win. This means that the exporter setting,
		      if enabled, will always override the importer setting (whatever that is). 
		    </para>
		  </sidebar>
		  
          <para>The permissible values for the
          <literal>context-class-loader</literal> attribute are:</para>
          
          <itemizedlist>
          	<listitem>
          	<para><literal>client</literal> - during the service invocation,
          	the context	class loader is guaranteed to be
          	able to see types on the classpath of the invoking bundle.
          	This is the default option.</para>
          	</listitem>

          	<listitem>
          	<para><literal>service-provider</literal> - during the service invocation,
          	the context	class loader is guaranteed to be
          	able to see types on the classpath of the bundle exporting
          	the service.</para>
          	</listitem>

          	<listitem>
          	<para><literal>unmanaged</literal> - no context class loader
          	management will occur during the service invocation</para>
          	</listitem>
          </itemizedlist>
          
        </section>

        <section id="service-registry:refs:singular:dynamics">
          <title>Dealing with Service dynamics</title>

          <para>The bean defined by the <literal>reference</literal> element
          is unchanging throughout the lifetime of the application context
          (the object reference remains constant). However, the OSGi service
          that backs the reference may come and go at any time. For a
          mandatory service reference (cardinality <literal>1..1</literal>),
          creation of the application context will block until a matching
          service is available. For an optional service reference, the
          reference bean will be created immediately, regardless of whether or
          not there is currently a matching service.</para>

          <para>When the service backing a <literal>reference</literal> bean
          goes away, Spring Dynamic Modules tries to replace the backing
          service with another service matching the reference criteria. An
          application may be notified of a change in backing service by
          registering a <literal>listener</literal>. If no matching service is
          available, then the <literal>reference</literal> is said to be
          <emphasis>unsatisfied</emphasis>. An unsatisfied mandatory service
          causes any exported service (<literal>service</literal> bean) that
          depends on it to be unregistered from the service registry until
          such time as the reference is satisfied again.</para>

          <para>When an operation is invoked on an unsatisfied
          <literal>reference</literal> bean (either optional or mandatory),
          the invocation blocks until the reference becomes satisfied. The
          optional <literal>timeout</literal> attribute of the
          <literal>reference</literal> element enables a timeout value (in
          milliseconds) to be specified. If a timeout value is specified and
          no matching service becomes available within the timeout period, an
          unchecked <classname>ServiceUnavailableException</classname> is
          thrown.</para>

          <para>For applications that need to be aware of when the service
          backing a <literal>reference</literal> bean is bound and unbound, it
          is possible to register one or more listeners using the nested
          <literal>listener</literal> element. The <literal>listener</literal>
          element refers to a bean (either by name, or by defining one inline)
          that will receive bind and unbind notifications. If this bean
          implements Spring's
          <interfacename>org.springframework.osgi.service.importer.OsgiServiceLifecycleListener</interfacename>
          interface, then the <literal>bind</literal> and
          <literal>unbind</literal> operations in this interface will be
          invoked. Instead of implementing this interface (or in addition),
          custom bind and unbind callback methods may be named.</para>

          <para>An example of declaring a listener that implements
          <interfacename>OsgiServiceLifecycleListener</interfacename>:</para>

          <programlisting><![CDATA[<reference id="someService" interface="com.xyz.MessageService">
  <listener ref="aListenerBean"/>
</reference>]]></programlisting>

          <para>An example of declaring an inline listener bean with custom
          bind and unbind methods:</para>

          <programlisting><![CDATA[<reference id="someService" interface="com.xyz.MessageService">
  <listener bind-method="onBind" unbind-method="onUnbind">
     <beans:bean class="MyCustomListener"/>
  </listener>
</reference>]]></programlisting>

          <para>If the listener bean implements the
          <interfacename>OsgiServiceLifecycleListener</interfacename> interface
          <emphasis>and</emphasis> the listener definition specifies custom
          bind and unbind operations then both the
          <literal>OsgiServiceLifecycleListener</literal> operation and the
          custom operation will be invoked, in that order.</para>

          <para>The signature of a custom bind or unbind method must be one
          of:</para>

          <programlisting><![CDATA[public void anyMethodName(ServiceType service, Dictionary properties);

public void anyMethodName(ServiceType service, Map properties);

public void anyMethodName(ServiceReference ref);]]></programlisting>

          <para>where <literal>ServiceType</literal> can be any type that is
          assignable from the <literal>reference</literal> interface type. The
          properties parameter contains the set of properties that the service
          was registered with.</para>

          <para>A bind callback is invoked when the reference is initially
          bound to a backing service, and whenever the backing service is
          replaced by a new backing service.</para>

          <para>An unbind callback is only invoked when the current backing
          service is unregistered, and no replacement service is immediately
          available (i.e., the <literal>reference</literal> becomes
          unsatisfied).</para>
          
          <para>In both cases, bind and unbind callbacks will be called <emphasis>only</emphasis>
          if the backing service matches the type declared in the method signature.
          If you want the callbacks to be called no matter the type, 
          use <classname>java.lang.Object</classname> as a <literal>ServiceType</literal>.
          </para>

          <para>Bind and unbind callbacks are made synchronously as part of
          processing an OSGi <literal>serviceChanged</literal> event for the
          backing OSGi service, and are invoked on the OSGi thread that
          delivers the corresponding OSGi
          <classname>ServiceEvent</classname>.</para>
          
          <para>If the method signature has a single argument of type
          <interfacename>ServiceReference</interfacename> then the
          <interfacename>ServiceReference</interfacename> of the service will be passed to
          the callback in place of the service object itself.</para>

        </section>
        
      	<section id="service-registry:refs:singular:reference:attributes">
       	<para>
       	As a summary, the following table lists the <literal>reference</literal> element 
       	attributes names, possible values and a short description for each of them.
        </para>
       	<table id="reference-import-options" pgwide="1">
          <title><![CDATA[OSGi <reference> attributes]]></title>
          <tgroup cols="3">
            <colspec align="center" />
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Values</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>interface</entry>
                <entry>fully qualified class name (such as <classname>java.lang.Thread</classname>)</entry>
                <entry>The fully qualified name of the class under which the object will be exported.</entry>
              </row>
              <row>
                <entry>filter</entry>
                <entry>OSGi filter expression (such as <literal>((asynchronous-delivery=true)</literal>)</entry>
                <entry>OSGi filter expression that is used to constrain the set of matching services
                in the service registry.</entry>
              </row>
              <row>
                <entry>bean-name</entry>
                <entry>any string value</entry>
                <entry>Convenient shortcut for specifying a filter expression that matches on the bean-name property 
                that is automatically advertised for beans published using the &lt;service&gt; element.</entry>
              </row>
              <row>
                <entry>context-class-loader</entry>
                <entry>client |  service-provider | unmanaged</entry>
                <entry>Defines how the context class loader is managed when invoking operations on a service
                backing this service reference. The default value is <literal>client</literal> which means that the context
                class loader has visibility of the resources on this bundle's classpath. Alternate
                options are <literal>service-provider</literal> which means that the context class loader has visibility of 
                resources on the bundle classpath of the bundle that exported the service, and <literal>unmanaged</literal>
               	which does not do any management of the context class loader.</entry>
              </row>
              <row>
                <entry>cardinality</entry>
                <entry>0..1 | 1..1</entry>
                <entry>Defines the required cardinality of the relationship to the backing service. If not specified, 
                the <literal>default-cardinality</literal> attribute will apply. A value is '1..1' means that a backing service 
                must exist (this is a mandatory service reference). A value of '0..1' indicates that it is 
                acceptable to be no backing service (an optional service reference).</entry>
              </row>
              <row>
                <entry>timeout</entry>
                <entry>any positive long</entry>
                <entry>The amount of time (in milliseconds) to wait for a backing service to be 
				available when an operation is invoked. If not specified, the <literal>default-timeout</literal> attribute will apply.
                </entry>
              </row>              
            </tbody>
          </tgroup>
	     </table>
	     
	     <para>The table below lists the attributes available for the <literal>reference</literal> <literal>listener</literal> sub element.</para>

       	 <table id="reference-import-listener-options" pgwide="1">
          <title><![CDATA[OSGi <listener> attributes]]></title>
          <tgroup cols="3">
            <colspec align="center" />
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Values</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>ref</entry>
                <entry>bean name reference</entry>
                <entry>Name based reference to another bean acting as listener.</entry>
              </row>
              <row>
                <entry>bind-method</entry>
                <entry>string representing a valid method name</entry>
                <entry>The name of the method to be invoked when a backing service is bound.</entry>
              </row>
              <row>
                <entry>unbind-method</entry>
                <entry>string representing a valid method name</entry>
                <entry>The name of the method to be invoked when a backing service is bound.</entry>
              </row>
            </tbody>
          </tgroup>
	     </table>	          
    	</section>
              
      </section>

      <section id="service-registry:refs:collection">
        <title>Referencing collections of services</title>

		<sidebar>
		 <title>Natural vs custom ordering</title>
		 <para>
		 Java collection API defines two interfaces for ordering objects -
		 <interfacename>Comparable</interfacename> and <interface>Comparator</interface>.
		 The first is meant to be implemented by objects for providing <emphasis>natural 
		 ordering</emphasis>. <classname>String</classname>, <classname>Long</classname>
		 or <classname>Date</classname> are good examples of objects that implement the
		 <interfacename>Comparable</interfacename> interface.</para>
		 <para>
		 However, there are cases where sorting is different then the natural ordering or,
		 the objects meant to be sort do not implement <interface>Comparable</interface>. To
		 address this cases, <interfacename>Comparator</interfacename> interface was designed. 
		 </para>
		 <para>For more information on this subject, please consult the <ulink url="http://java.sun.com/docs/books/tutorial/collections/interfaces/order.html">
		 Object ordering</ulink> chapter from Java 
		 <ulink url="http://java.sun.com/docs/books/tutorial/collections/">collection</ulink> tutorial,
		 </para>
		</sidebar>
		
        <para>Sometimes an application needs access not simply to any service
        meeting some criteria, but to <emphasis>all</emphasis> services
        meeting some criteria. Spring-DM allows the matching services may be held in a
        <interfacename>List</interfacename> or <interfacename>Set</interfacename> 
        (optionally sorted).</para>

        <para>The difference between using a <interfacename>List</interfacename> and a
        <interfacename>Set</interfacename> to manage the collection is one of equality.
        Two or more services published in the registry (and with distinct
        service ids) may be "equal" to each other, depending on the
        implementation of equals used by the service implementations. Only one
        such service will be present in a set, whereas all services returned
        from the registry will be present in a list. For more details on collections,
        see <ulink url="http://java.sun.com/docs/books/tutorial/collections/interfaces/index.html">this</ulink> 
        tutorial.</para>
        
        <para>The <literal>set</literal> and <literal>list</literal> schema elements
        are used to define collections of services with set or list semantics
        respectively.</para>

        <para>These elements support the attributes
        <literal>interface</literal>, <literal>filter</literal>,
        <literal>bean-name</literal>, <literal>cardinality</literal>, and
        <literal>context-class-loader</literal>, with the same semantics as for
        the <literal>reference</literal> element. The allowable values for the
        <literal>cardinality</literal> attribute are <literal>0..N</literal>
        and <literal>1..N</literal>.</para>
        
        <para>A cardinality value of
        <literal>0..n</literal> indicates that it is permissible for their to
        be no matching services. A cardinality value of
        <literal>1..n</literal> indicates that at least one matching service
        is required at all times. Such a reference is considered a
        <emphasis>mandatory</emphasis> reference and any exported services
        from the same bundle (<literal>service</literal> defined beans) that
        depend on a mandatory reference will automatically be unregistered
        when the reference becomes unsatisfied, and reregistered when the
        reference becomes satisfied again.</para>

        <para>The bean defined by a <literal>list</literal> element is of type
        <interfacename>java.util.List</interfacename>. The bean defined by a
        <literal>set</literal> element is of type
        <interfacename>java.util.Set</interfacename>.</para>

        <para>The following example defines a bean of type <interfacename>List</interfacename> that 
        will contain all registered services supporting the
        <literal>EventListener</literal> interface:</para>

        <programlisting><![CDATA[<list id="myEventListeners" 
  interface="com.xyz.EventListener"/>]]></programlisting>

        <para>The members of the collection defined by the bean are managed
        dynamically by Spring. As matching services are registered and
        unregistered in the service registry, the collection membership will
        be kept up to date. Each member of the collection supports the service
        interfaces that the corresponding service was registered with and that
        are visible to the bundle.</para>

		<para>Spring-DM supports sorted collections as well, both for set and list.</para>
        <para>It is possible to specify a sorting order using either the
        <literal>comparator-ref</literal> attribute, or the nested
        <literal>comparator</literal> element. The
        <literal>comparator-ref</literal> attribute is used to refer to a
        named bean implementing <interfacename>java.util.Comparator</interfacename>. The
        <literal>comparator</literal> element can be used to define an inline
        bean. For example:</para>

        <programlisting><![CDATA[<set id="myServices" interface="com.xyz.MyService"
  comparator-ref="someComparator"/>

<list id="myOtherServices" 
  interface="com.xyz.OtherService">
  <comparator>
     <beans:bean class="MyOtherServiceComparator"/>
  </comparator>
</list>]]></programlisting>

	
        <para>To sort using a natural ordering instead of an explicit
        comparator, you can use the <literal>natural-ordering</literal>
        element inside of <literal>comparator</literal>. You need to specify
        the basis for the natural ordering: based on the service references,
        following the <interfacename>ServiceReference</interfacename> natural ordering
        defined in the OSGi Core Specification section 6.1.2.3; or based on
        the services themselves (in which case the services must be
        <interfacename>Comparable</interfacename>).</para>

        <programlisting><![CDATA[<list id="myServices" interface"com.xyz.MyService">
  <comparator><natural-ordering basis="services"/></comparator>
</list>

<set id="myOtherServices"interface="com.xyz.OtherService">
  <comparator><natural-ordering basis="service-references"/></comparator>
</set>]]></programlisting>

		<para>For a sorted set, a <interfacename>SortedSet</interfacename> implementation will be created.
		However, since JDK API do not provide a <interfacename>SortedList</interfacename>, a sorted list
		will still be returned as a <interfacename>List</interfacename> implementation.</para>

		<section id="service-registry:refs:collection:iterator">
		  <title><interfacename>Iterator</interfacename> contract and dynamic collections</title>

		  <para>The recommend way of traversing a collection is by using an <interfacename>Iterator</interfacename>.
		  However, since OSGi services can come and go, the content of the managed service collection will be adjusted
		  accordingly. Spring-DM will transparently update any collection <interfacename>Iterator</interfacename>s held by 
		  the user so it is possible to safely traverse the collection while it is being modified. Moreover, the 
		  <interfacename>Iterator</interfacename> will reflect all the changes made to the collection, even if 
		  they occurred after the <interfacename>Iterator</interfacename> was created or during the iteration.
		  Consider a case where a collection shrinks significantly (for example a big number of OSGi
		  services are shutdown) right after an iteration started.
		  To avoid dealing with a lot of 'dead' service references that throw exceptions on usage,
		  Spring-DM iterators do not take collection snapshots but rather are updated on each service
		  event so they reflect the latest collection state, no matter how fast or slow the iteration is.</para>
		  
		  <para>Please note that the <interfacename>Iterator</interfacename> contract is guaranteed meaning that 
		  <literal>next()</literal> method <emphasis>always</emphasis> obey the result of the previous 
		  <literal>hasNext()</literal> invocation.</para>

		  <table id="collection-iterator-contract" pgwide="1">
           <title>Dynamic service collection <interfacename>Iterator</interfacename> contract</title>
           <tgroup cols="2">
            <colspec align="center" />
            <thead>
              <row>
                <entry>hasNext() returned value</entry>
                <entry>next() behaviour</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>true</entry>
                <entry><emphasis>Always</emphasis> return a non-null value, even when the collection has shrunk as services when away.
                </entry>
              </row>
              <row>
                <entry>false</entry>
                <entry>per <interfacename>Iterator</interfacename> contract, <classname>NoSuchElementException</classname> is thrown.
                This applies even if other services are added to the collection</entry>
              </row>
            </tbody>
           </tgroup>
	      </table>
	      
	      <para>
	      The behaviour described above, offers a consistent view over the collection even if its structure changes during iteration.
	      To simply <emphasis>refresh</emphasis> the iterator, call <literal>hasNext()</literal> again. This will force the
	      <literal>Iterator</literal> to check again the collection status for its particular entry in the iteration.</para>
	      	
	 	  <para>
	 	  In addition, any elements added to the collection during iteration over a <emphasis>sorted</emphasis>
          collection will only be visible if the iterator has not already passed
          their sort point.</para>
        </section>
        
        <section id="service-registry:refs:collection:dynamics">
          <title>Dealing with Service dynamics</title>

          <para>Collection membership is automatically managed as matching
          services are registered or unregistered. The nested
          <literal>listener</literal> element is supported with all of the
          reference collection beans. The bind callback is invoked whenever a
          service is added to the collection, and the unbind callback is
          invoked whenever a service is removed from the collection.</para>

          <para>When iterating over the members of a collection, it is always
          possible that the service backing a collection member is
          unregistered after it has been returned from an invocation of
          <literal>Iterator.next()</literal>. If an operation is invoked on
          such a service, a <literal>ServiceUnavailableException</literal>
          will be thrown.</para>
        </section>
        
        
        <section id="service-registry:refs:singular:collection:attributes">
       	<para>
       	As a summary, the following table lists the <literal>set</literal> and <literal>list</literal> element 
       	attributes names, possible values and a short description for each of them.
        </para>
       	<table id="collection-import-options" pgwide="1">
          <title><![CDATA[OSGi <reference> attributes]]></title>
          <tgroup cols="3">
            <colspec align="center" />
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Values</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>interface</entry>
                <entry>fully qualified class name (such as <classname>java.lang.Thread</classname>)</entry>
                <entry>The fully qualified name of the class under which the object will be exported.</entry>
              </row>
              <row>
                <entry>filter</entry>
                <entry>OSGi filter expression (such as <literal>((asynchronous-delivery=true)</literal>)</entry>
                <entry>OSGi filter expression that is used to constrain the set of matching services
                in the service registry.</entry>
              </row>
              <row>
                <entry>bean-name</entry>
                <entry>any string value</entry>
                <entry>Convenient shortcut for specifying a filter expression that matches on the bean-name property 
                that is automatically advertised for beans published using the &lt;service&gt; element.</entry>
              </row>
              <row>
                <entry>context-class-loader</entry>
                <entry>client |  service-provider | unmanaged</entry>
                <entry>Defines how the context class loader is managed when invoking operations on a service
                backing this service reference. The default value is <literal>client</literal> which means that the context
                class loader has visibility of the resources on this bundle's classpath. Alternate
                options are <literal>service-provider</literal> which means that the context class loader has visibility of 
                resources on the bundle classpath of the bundle that exported the service, and <literal>unmanaged</literal>
               	which does not do any management of the context class loader.</entry>
              </row>
              <row>
                <entry>cardinality</entry>
                <entry>0..N | 1..N</entry>
                <entry>Defines the required cardinality of the relationship to the backing service. If not specified, 
                the <literal>default-cardinality</literal> attribute will apply. A value is '1..N' means that a backing service 
                must exist (this is a mandatory service reference). A value of '0..N' indicates that it is 
                acceptable to be no backing service (an optional service reference).</entry>
              </row>
              <row>
                <entry>comparator-ref</entry>
                <entry>any string value</entry>
                <entry>Named reference to a bean acting as comparator for the declaring collection. Declaring a comparator automatically
                makes the declaring collection sorted.</entry>
              </row>              
            </tbody>
          </tgroup>
	     </table>
	     
	     <para>The table below lists the attributes available for the <literal>comparator/natural</literal> sub element.</para>

       	 <table id="collection-import-comparator-options" pgwide="1">
          <title><![CDATA[OSGi <listener> attributes]]></title>
          <tgroup cols="3">
            <colspec align="center" />
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Values</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>basis</entry>
                <entry>service | service-reference</entry>
                <entry>Indicate the element on which <emphasis>natural ordering</emphasis> should apply - <literal>service</literal> for considering
                the service instance and <literal>service-reference</literal> for considering the service reference instead of the service.</entry>
              </row>
            </tbody>
          </tgroup>
	     </table>	          
    	</section>
              
      </section>
      
    </section>
    
    <section id="service-registry:refs:global-defaults">
      <title>Service importer global defaults</title>

  	  <para>The <literal>osgi</literal> namespace allows offers two
  	  global attributes for specifying default behaviours for all
  	  importers declared in that file.</para>
  	        
      <para>Thus, when using the <literal>osgi</literal> namespace to enclose
      <literal>set</literal>, <literal>list</literal> or 
      <literal>reference</literal> elements, one can use:</para>
      
      <itemizedlist>
        <listitem>
        <para><literal>default-timeout</literal> - 
      can be used to specify the default timeout (in milliseconds) for all
      importer elements that do not explicitly specify one. For
      example:</para>

      <programlisting><![CDATA[<beans:beans osgi:default-timeout="5000">

  <!-- we will wait up to 5 seconds for a matching service on
       invocation -->
  <reference id="someService" interface="com.xyz.AService" .../>

  <!-- we will wait only 1 second for a matching service on 
       invocation -->
  <reference id="someOtherService" interface="com.xyz.BService"
       timeout="1000" .../>

</beans:beans>]]></programlisting>

		</listitem>

		<listitem>
		<para><literal>default-cardinality</literal> -
		can be used to specify the default cardinality for all
      	importer elements that do not explicitly specify one.
      	Possible values are <literal>0..X</literal> and <literal>1..X</literal>
      	where <literal>X</literal> is substituted at runtime to <literal>1</literal>
      	for <literal>reference</literal> elements or <literal>N</literal>
      	for collection types such as <literal>set</literal> or <literal>list</literal>.
      	</para>
      	
      	<para>Consider the following example:</para>
      <programlisting><![CDATA[<beans:beans osgi:default-cardinality="0..X">

  <!-- no cardinality specified, global cardinality inherited = 0..1 -->
  <reference id="someService" interface="com.xyz.AService"/>

  <!-- no cardinality specified, global cardinality inherited = 0..N -->
  <set id="someSetOfService" interface="com.xyz.BService"/>

  <!-- local cardinality cardinality specified, override global attribute -->
  <list id="anotherListOfServices" interface="com.xyz.CService" cardinality="1..N"/>

</beans:beans>]]></programlisting>
		</listitem>
      </itemizedlist>
      
      <para>The <literal>default-*</literal> attributes allow for concise and shorter declarations as well
      as easy propagation of changes (such as increasing or decreasing the timeout).</para>
    </section>
    
    <section id="service-registry:refs:listener-best-practices">
      <title>Exporter/Importer listener best practices</title>
      
      <para>As mentioned above, Spring-DM exporter and importer allow listeners to be
      used for receiving notifications on when services are bound, unbound, registered or 
      unregistered. Below you can find some guidance advices when working with listeners:
      </para>
      
      <itemizedlist>
       	<listitem>
       	Do <emphasis>not</emphasis> execute long activity tasks inside the listener. If you really
       	have to, use a separate thread for executing the work. The listener are called synchronously
       	and so try to be as fast as possible. Doing work inside the listener prevents other the event
       	to be sent to other listeners and the OSGi service to resume activity. 
      	</listitem>
      
      
      	<listitem>Use listener custom declaration as much as possible - it doesn't tie your code
      	to Spring-DM API and it doesn't enforce certain signature names.</listitem>
      	
      	<listitem>If find yourself repeating bind/unbind method declarations for your listener definitions,
      	consider using Spring <ulink url="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-child-bean-definitions">
      	bean definition inheritance</ulink> to define a common definition that can be reused and customized
      	accordingly.
      	</listitem>
      	
      	<listitem>Prefer <interfacename>java.util.Map</interfacename> instead of <classname>java.util.Dictionary</classname>
      	class. The first is an interface while the latter is a deprecated, abstract class. To preserve compatibility, Spring-DM
      	will pass to the listeners a <interfacename>Map</interfacename> implementation that can be casted, if needed, to a 
      	<classname>Dictionary</classname>.</listitem>
      </itemizedlist> 
      
    </section>
    
    <section id="service-registry:export-import-relationship">
    
     <title>Relationship between the service exporter and service importer</title>
       	
        <para>An exported service may depend, either directly or indirectly,
        on other services in order to perform its function. If one of these
        services is considered a <emphasis>mandatory</emphasis> dependency
        (see <xref linkend="service-registry:refs:singular:dynamics"/>) and the 
        dependency can no longer be satisfied
        (because the backing service has gone away and there is no suitable
        replacement available) then the exported service that depends on it
        will be automatically unregistered from the service registry - meaning
        that it is no longer available to clients. If the mandatory dependency
        becomes satisfied once more (by registration of a suitable service),
        then the exported service will be re-registered in the service
        registry.</para>

        <para>This automatic unregistering and re-registering of exported
        services based on the availability of mandatory dependencies only
        takes into account declarative dependencies. If exported service
        <literal>S</literal> depends on bean <literal>A</literal>, which in
        turn depends on mandatory imported service <literal>M</literal>, and
        these dependencies are explicit in the Spring configuration file as
        per the example below, then when <literal>M</literal> becomes
        unsatisfied <literal>S</literal> will be unregistered. When
        <literal>M</literal> becomes satisfied again, <literal>S</literal>
        will be re-registered.</para>

        <programlisting><![CDATA[<osgi:service id="S" ref="A" interface="SomeInterface"/>

<bean id="A" class="SomeImplementation">
   <property name="helperService" ref="M"/>
</bean> 

<!-- the reference element is used to refer to a service
     in the service registry -->
<osgi:reference id="M" interface="HelperService"
     cardinality="1..1"/>]]></programlisting>

        <para>If however the dependency from <literal>A</literal> on
        <literal>M</literal> is not established through configuration as shown
        above, but instead at runtime through for example passing a reference
        to <literal>M</literal> to <literal>A</literal> without any
        involvement from the Spring container, then Spring Dynamic Modules
        will <emphasis>not</emphasis> track this dependency.</para>
    
    </section>
  </chapter>
