  <chapter id="service-registry">
    <title>The Service Registry</title>

    <para>The OSGi service registry enables a bundle to publish objects to a
    shared registry, advertised via a given set of Java interfaces. Published
    services also have service properties associated with them in the
    registry.</para>

    <para>Spring Dynamic Modules provides an 'osgi' namespace for Spring (see
    Appendix B) that can be used to export Spring beans as OSGi services, and
    to define references to services obtained via the service registry. The
    namespace elements may be used nested inside another top-level namespace
    (typically the Spring 'beans' namespace), or within the top-level
    <literal>osgi</literal> element.</para>

    <para>The following example shows the use of the <literal>osgi</literal>
    namespace within the familiar Spring beans element:</para>

    <screen>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:osgi="http://www.springframework.org/schema/osgi"
   xsi:schemaLocation="http://www.springframework.org/schema/beans   
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/osgi  
       http://www.springframework.org/schema/osgi/spring-osgi-2.5.xsd"&gt;

    &lt;!-- use the OSGi namespace elements qualified with 'osgi:' --&gt;
    &lt;osgi:service id="simpleServiceOsgi" ref="simpleService"
      interface="org.xyz.MyService" /&gt;

&lt;/beans&gt;</screen>

    <para>Using the OSGi namespace as a top-level namespace the same service
    would be declared as follows:</para>

    <screen>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns="http://www.springframework.org/schema/osgi"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:beans="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/osgi  
       http://www.springframework.org/schema/osgi/spring-osgi.xsd
       http://www.springframework.org/schema/beans   
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

  &lt;!-- use the OSGi namespace elements directly --&gt;
  &lt;service id="simpleServiceOsgi" ref="simpleService"
       interface="org.xyz.MyService" /&gt;

&lt;/beans:beans&gt;</screen>

    <para>Using the OSGi namespace as a top-level namespace is particularly
    convenient when following the recommendation of section 3.1 to use a
    dedicated configuration file for all OSGi-related declarations.</para>

    <section id="service-registry:export">
      <title>4.1 Exporting a Spring bean as an OSGi service</title>

      <para>The <literal>service</literal> element is used to define a bean
      representing an exported OSGi service. At a minimum you must specify the
      bean to be exported, and the <emphasis>service interface</emphasis> that
      the service offers.</para>

      <para>For example, the declaration</para>

      <screen>&lt;service ref="beanToPublish" interface="com.xyz.MessageService"/&gt;</screen>

      <para>exports the bean with name <literal>beanToPublish</literal> with
      interface <literal>com.xyz.MessageService</literal>. The published
      service will have a service property with the name
      <literal>org.springframework.osgi.beanname</literal> set to the name of
      the target bean being registered (<literal>beanToPublish</literal> in
      this case).</para>

      <para>The bean <emphasis>defined</emphasis> by the
      <literal>service</literal> element is of type
      <literal>org.osgi.framework.ServiceRegistration</literal> and is the
      <literal>ServiceRegistration</literal> object resulting from registering
      the exported bean with the OSGi service registry. By giving this bean an
      id you can inject a reference to the
      <literal>ServiceRegistration</literal> object into other beans if
      needed. For example:</para>

      <screen>&lt;service id="myServiceRegistration" ref="beanToPublish"
    interface="com.xyz.MessageService"/&gt;</screen>

      <para>As an alternative to exporting a named bean, the bean to be
      exported to the service registry may be defined as an anonymous inner
      bean of the service element. Typically the top-level namespace would be
      the <literal>beans</literal> namespace when using this style:</para>

      <screen>&lt;osgi:service interface="com.xyz.MessageService"&gt;
  &lt;bean class="SomeClass"&gt;
     ...
  &lt;/bean&gt;
&lt;/osgi:service&gt;</screen>

      <para>If the bean to be exported implements the
      <literal>org.osgi.framework.ServiceFactory</literal> interface then the
      <literal>ServiceFactory</literal> contract is honored as per section 5.6
      of the OSGi Service Platform Core Specification. As an alternative to
      implementing this OSGi API, Spring Dynamic Modules introduces a new bean
      scope, the <literal>bundle</literal> scope. When a bean with bundle
      scope is exported as an OSGi service then one instance of the bean will
      be created for each unique client (service importing) bundle that
      obtains a reference to it through the OSGi service registry. When a
      service importing bundle is stopped, the bean instance associated with
      it is disposed. To declare a bean with <literal>bundle</literal> scope
      simply use the <literal>scope</literal> attribute of the
      <literal>bean</literal> element:</para>

      <screen>&lt;osgi:service ref="beanToBeExported" interface="com.xyz.MessageService"/&gt;

&lt;bean id="beanToBeExported" scope="bundle" class="com.xyz.MessageServiceImpl"/&gt;</screen>

      <section id="service-registry:export:intfs">
        <title>Controlling the set of advertised service interfaces for
        an exported service</title>

        <para>The OSGi Service Platform Core Specification defines the term
        <emphasis>service interface</emphasis> to represent the specification
        of a service's public methods. Typically this will be a Java
        interface, but the specification also supports registering service
        objects under a class name, so the phrase <emphasis>service
        interface</emphasis> can be interpreted as referring to either an
        interface or a class.</para>

        <para>There are several options for specifying the service
        interface(s) under which the exported service is registered. The
        simplest mechanism, shown above, is to use the
        <literal>interface</literal> attribute to specify a fully-qualified
        interface name. To register a service under multiple interfaces the
        nested <literal>interfaces</literal> element can be used in place of
        the <literal>interface</literal> attribute.</para>

        <screen>&lt;osgi:service ref="beanToBeExported"&gt;
  &lt;osgi:interfaces&gt;
     &lt;value&gt;com.xyz.MessageService&lt;/value&gt;
     &lt;value&gt;com.xyz.MarkerInterface&lt;/value&gt;
  &lt;/osgi:interfaces&gt;
&lt;/osgi:service&gt;</screen>

        <para>Using the <literal>auto-export</literal> attribute you can avoid
        the need to explicitly declare the service interfaces at all. The
        <literal>auto-export</literal> attribute can have one of four
        values:</para>

        <itemizedlist>
          <listitem>
            <para>disabled : the default value; no auto-detected of service
            interfaces is undertaken and the <literal>interface</literal>
            attribute or <literal>interfaces</literal> element must be used
            instead.</para>
          </listitem>

          <listitem>
            <para>interfaces : the service will be registered using all of the
            Java interface types implemented by the bean to be exported</para>
          </listitem>

          <listitem>
            <para>class-hierarchy : the service will be registered using the
            exported bean's implementation type and super-types</para>
          </listitem>

          <listitem>
            <para>all : the service will be registered using the exported
            bean's implementation type and super-types plus all interfaces
            implemented by the bean.</para>
          </listitem>
        </itemizedlist>

        <para>For example, to automatically register a bean under all of the
        interfaces that it supports you would declare:</para>

        <screen>&lt;service ref="beanToBeExported" auto-export="interfaces"/&gt;</screen>

        <para>Given the interface hierarchy:</para>

        <screen>public interface SuperInterface {}

public interface SubInterface extends SuperInterface {}</screen>

        <para>then a service registered as supporting the
        <literal>SubInterface</literal> interface is <emphasis>not</emphasis>
        considered a match in OSGi when a lookup is done for services
        supporting the <literal>SuperInterface</literal> interface. For this
        reason it is a best practice to export all interfaces supported by the
        service being registered explicitly, using either the
        <literal>interfaces</literal> element or
        <literal>auto-export="interfaces"</literal>.</para>

        <para>Note that when using auto-export, only types visible to the
        bundle exporting the service are registered. For example, a
        super-interface <literal>SI</literal> would not be exported as a
        supported service interface even when using
        <literal>auto-export="interfaces"</literal> if <literal>SI</literal>
        was not on the exporting bundle's classpath.</para>
      </section>

      <section id="service-registry:export:props">
        <title>Controlling the set of advertised properties for an
        exported service</title>

        <para>As previously described, an exported service is always
        registered with the service property
        <literal>org.springframework.osgi.beanname</literal> set to the name
        of the bean being exported. Additional service properties can be
        specified using the nested <literal>service-properties</literal>
        element. The <literal>service-properties</literal> element contains
        key-value pairs to be included in the advertised properties of the
        service. The key must be a string value, and the value must be a type
        recognized by OSGi Filters. See section 5.5 of the OSGi Service
        Platform Core Specification for details of how property values are
        matched against filter expressions.</para>

        <para>The <literal>service-properties</literal> element must contain
        at least one nested <literal>entry</literal> element from the Spring
        beans namespace. For example:</para>

        <screen>&lt;service ref="beanToBeExported" interface="com.xyz.MyServiceInterface"&gt;
  &lt;service-properties&gt;
    &lt;beans:entry key="myOtherKey" value="aStringValue"/&gt;
    &lt;beans:entry key="aThirdKey" value-ref="beanToExposeAsProperty"/&gt;
  &lt;service-properties&gt;
&lt;/service&gt;</screen>

        <para>The Spring Dynamic Modules roadmap includes support for
        exporting properties registered in the OSGi Configuration
        Administration service as properties of the registered service. See
        Appendix A for more details.</para>
      </section>

      <section id="service-registry:export:depends-on">
        <title>The depends-on attribute</title>

        <para>Spring will manage explicit dependencies of a service element,
        ensuring for example that the bean to be exported as a service is
        fully constructed and configured before exporting it. If a service has
        implicit dependencies on other components (including other service
        elements) that must be fully initialized before the service can be
        exported, then the optional <literal>depends-on</literal> attribute
        can be used to express these dependencies.</para>

        <screen>&lt;service ref="beanToBeExported" interface="com.xyz.MyServiceInterface"
     depends-on="myOtherComponent"/&gt;</screen>
      </section>

      <section id="service-registry:export:ranking">
        <title>The ranking attribute</title>

        <para>When registering a service with the service registry, you may
        optionally specify a service ranking (see section 5.2.5 of the OSGi
        Service Platform Core Specification). When a bundle looks up a service
        in the service registry, given two or more matching services the one
        with the highest ranking will be returned. The default ranking value
        is zero. To explicitly specify a ranking value for the registered
        service, use the optional <literal>ranking</literal> attribute.</para>

        <screen>&lt;service ref="beanToBeExported" interface="com.xyz.MyServiceInterface"
  ranking="9"/&gt;</screen>
      </section>

      <section id="service-registry:export:ccl">
        <title>The context-class-loader attribute</title>

        <para>The OSGi Service Platform Core Specification (most current
        version is 4.1 at time of writing) does not specify what types and
        resources are visible through the context class loader when an
        operation is invoked on a service obtained via the service registry.
        Since some services may use libraries that make certain assumptions
        about the context class loader, Spring Dynamic Modules enables you to
        explicitly control the context class loader during service execution.
        This is achieved using the option
        <literal>context-class-loader</literal> attribute of the service
        element.</para>

        <para>The permissible values for the
        <literal>context-class-loader</literal> attribute are
        <literal>unmanaged</literal> (the default) and
        <literal>service-provider</literal>. When the
        <literal>service-provider</literal> value is specified, Spring Dynamic
        Modules ensures that the context class loader can see all of the
        resources on the class path of the bundle defining the service.</para>
      </section>

      <section id="service-registry:export:lifecycle">
        <title>Service registration and unregistration lifecycle</title>

        <para>The service defined by a <literal>service</literal> element is
        registered with the OSGi service registry when the application context
        is first created. It will be unregistered automatically when the
        bundle is stopped and the application context is disposed.</para>

        <para>An exported service may depend, either directly or indirectly,
        on other services in order to perform its function. If one of these
        services is considered a <emphasis>mandatory</emphasis> dependency
        (see section 4.2) and the dependency can no longer be satisfied
        (because the backing service has gone away and there is no suitable
        replacement available) then the exported service that depends on it
        will be automatically unregistered from the service registry - meaning
        that it is no longer available to clients. If the mandatory dependency
        becomes satisfied once more (by registration of a suitable service),
        then the exported service will be re-registered in the service
        registry.</para>

        <para>This automatic unregistering and re-registering of exported
        services based on the availability of mandatory dependencies only
        takes into account declarative dependencies. If exported service
        <literal>S</literal> depends on bean <literal>A</literal>, which in
        turn depends on mandatory imported service <literal>M</literal>, and
        these dependencies are explicit in the Spring configuration file as
        per the example below, then when <literal>M</literal> becomes
        unsatisfied <literal>S</literal> will be unregistered. When
        <literal>M</literal> becomes satisfied again, <literal>S</literal>
        will be re-registered.</para>

        <screen>&lt;osgi:service id="S" ref="A" interface="SomeInterface"/&gt;

&lt;bean id="A" class="SomeImplementation"&gt;
   &lt;property name="helperService" ref="M"/&gt;
&lt;/bean&gt; 

&lt;!-- the reference element is used to refer to a service
     in the service registry --&gt;
&lt;osgi:reference id="M" interface="HelperService"
     cardinality="1..1"/&gt;</screen>

        <para>If however the dependency from <literal>A</literal> on
        <literal>M</literal> is not established through configuration as shown
        above, but instead at runtime through for example passing a reference
        to <literal>M</literal> to <literal>A</literal> without any
        involvement from the Spring container, then Spring Dynamic Modules
        will <emphasis>not</emphasis> track this dependency.</para>

        <para>If you need to take some action when a service is unregistered
        because its dependencies are not satisfied (or when it is registered),
        then you can define a listener bean using the nested
        <literal>registration-listener</literal> element.</para>

        <para>The declaration of a registration listener must use either the
        <literal>ref</literal> attribute to refer to a top-level bean
        definition, or declare an anonymous listener bean inline. For
        example:</para>

        <screen>&lt;!-- example service declaration with two listeners --&gt;

&lt;service ref="beanToBeExported" interface="SomeInterface"&gt;
  &lt;registration-listener ref="myListener"
    registration-method="serviceRegistered"
    unregistration-method="serviceUnregistered"/&gt;
  &lt;registration-listener
     registration-method="register"
     unregistration-method="unregister"&gt;
     &lt;bean class="SomeListenerClass"/&gt;
  &lt;/registration-listener&gt;
&lt;/service&gt;</screen>

        <para>The optional <literal>registration-method</literal> and
        <literal>unregistration-method</literal> attributes specify the names
        of the methods defined on the listener bean that are to be invoked
        during registration and unregistration. A registration callback method
        must have a signature matching the following format</para>

        <screen>public void anyMethodName(ServiceType serviceInstance);</screen>

        <para>where <literal>ServiceType</literal> can be any type compatible
        with the exported service interface of the service.</para>

        <para>An unregistration callback method must have a signature of the
        form</para>

        <screen>public void anyMethodName(ServiceType serviceInstance);</screen>

        <para>where <literal>ServiceType</literal> can be any type compatible
        with the exported service interface of the service.</para>

        <para>The register callback is invoked when the service is initially
        registered at startup, and whenever it is subsequently re-registered.
        The unregister callback is invoked immediately after the service is
        unregistered, including when the service is unregistered because the
        bundle is stopping.</para>
      </section>
    </section>

    <section id="service-registry:refs">
      <title>Defining references to OSGi services</title>

      <para>Spring Dynamic Modules supports the declaration of beans that
      represent services accessed via the OSGi Service Registry. In this
      manner references to OSGi services can be injected into application
      components. The service lookup is made using the service interface type
      that the service is required to support, plus an optional filter
      expression that matches against the service properties published in the
      registry.</para>

      <para>For some scenarios, a single matching service that meets the
      application requirements is all that is needed. The
      <literal>reference</literal> element defines a reference to a single
      service that meets the required specification. In other scenarios,
      especially when using the OSGi <ulink
      url="www.osgi.org/documents/osgi_technology/whiteboard.pdf">whiteboard
      pattern</ulink>, references to <emphasis>all available</emphasis>
      matching services are required. Spring Dynamic Modules supports the
      management of this set of references as a <literal>List</literal>,
      <literal>Set</literal>.</para>

      <section id="service-registry:refs:singular">
        <title>Referencing an individual service</title>

        <para>The <literal>reference</literal> element is used to define a
        reference to a service in the service registry. The
        <literal>interface</literal> attribute identifies the service
        interface that a matching service must implement. For example, the
        following declaration creates a bean
        <literal>messageService</literal>, which is backed by the service
        returned from the service registry when querying it for a service
        offering the <literal>MessageService</literal> interface.</para>

        <screen>&lt;reference id="messageService" interface="com.xyz.MessageService"/&gt;</screen>

        <para>If there are several services in the service registry then the
        service returned is the service that would be returned by a call to
        <literal>BundleContext.getServiceReference</literal>. This means that
        the service with the highest ranking will be returned, or if there is
        a tie in ranking, the service with the lowest service id (the service
        registered first with the framework) is returned.</para>

        <para>The bean defined by the reference element implements all of the
        registered interfaces of the service that are visible to the bundle.
        If the registered service interfaces include Java class types (as
        opposed to interface types) then support for these types is subject to
        the restrictions of Spring's AOP implementation (see the Spring
        Reference Guide). In short, <literal>cglib</literal> must be
        available, and <literal>final</literal> methods are not
        supported.</para>

        <para>If the property into which a reference bean is to be injected
        has type <literal>ServiceReference</literal> (instead of the service
        interface supported by the reference), then the OSGi
        <literal>ServiceReference</literal> for the service will be injected
        in place of the service itself.</para>

        <section id="service-registry:refs:singular:filter">
          <title>The filter attribute</title>

          <para>The optional <literal>filter</literal> attribute can be used
          to specify an OSGi filter expression and constrains the service
          registry lookup to only those services that match the given
          filter.</para>

          <para>For example:</para>

          <screen>&lt;reference id="asyncMessageService" interface="com.xyz.MessageService"
  filter="(asynchronous-delivery=true)"/&gt;</screen>
        </section>

        <section id="service-registry:refs:singular:bean-name">
          <title>The bean-name attribute</title>

          <para>The <literal>bean-name</literal> attribute is a convenient
          short-cut for specifying a filter expression that matches on the
          bean-name property automatically set when exporting a bean using the
          <literal>service</literal> element (see section 4.1).</para>

          <para>For example:</para>

          <screen>&lt;reference id="messageService" interface="com.xyz.MessageService"
   bean-name="defaultMessageService"/&gt;</screen>
        </section>

        <section id="service-registry:refs:singular:cardinality">
          <title>The cardinality attribute</title>

          <para>The <literal>cardinality</literal> attribute is used to
          specify whether or not a matching service is required at all times.
          A cardinality value of <literal>1..1</literal> (the default)
          indicates that a matching service must always be available. A
          cardinality value of <literal>0..1</literal> indicates that a
          matching service is not required at all times (see section 4.2.1.6
          for more details). A <literal>reference</literal> with cardinality
          <literal>1..1</literal> is also known as a
          <emphasis>mandatory</emphasis> service reference and by default
          application context creation is deferred until the reference is
          satisfied.</para>

          <para>Note: it is an error to declare a mandatory reference to a
          service that is also exported by the same bundle, this behavior can
          cause application context creation to fail through either deadlock
          or timeout.</para>
        </section>

        <section id="service-registry:refs:singular:depends-on">
          <title>The depends-on attribute</title>

          <para>The <literal>depends-on</literal> attribute is used to specify
          that the service reference should not be looked up in the service
          registry until the named dependent bean has been
          instantiated.</para>
        </section>

        <section id="service-registry:refs:singular:tccl">
          <title>The context-class-loader attribute</title>

          <para>The OSGi Service Platform Core Specification (most current
          version is 4.1 at time of writing) does not specify what types and
          resources are visible through the context class loader when an
          operation is invoked on a service obtained via the service registry.
          Since some services may use libraries that make certain assumptions
          about the context class loader, Spring Dynamic Modules enables you
          to explicitly control the context class loader during service
          invocation. This is achieved using the option
          <literal>context-class-loader</literal> attribute of the
          <literal>reference</literal> element.</para>

          <para>The permissible values for the
          <literal>context-class-loader</literal> attribute are
          <literal>unmanaged</literal> (the default),
          <literal>client</literal>, and <literal>service-provider</literal>.
          When the <literal>client</literal> value is specified, the context
          class loader at the point of service invocation is guaranteed to be
          able to see types on the classpath of the invoking bundle. When the
          <literal>service-provider</literal> value is specified, the context
          class loader is guaranteed to be able to see types on the classpath
          of the bundle that exported the service.</para>
        </section>

        <section id="service-registry:refs:singular:dynamics">
          <title>Dealing with Service dynamics</title>

          <para>The bean defined by the <literal>reference</literal> element
          is unchanging throughout the lifetime of the application context
          (the object reference remains constant). However, the OSGi service
          that backs the reference may come and go at any time. For a
          mandatory service reference (cardinality <literal>1..1</literal>),
          creation of the application context will block until a matching
          service is available. For an optional service reference, the
          reference bean will be created immediately, regardless of whether or
          not there is currently a matching service.</para>

          <para>When the service backing a <literal>reference</literal> bean
          goes away, Spring Dynamic Modules tries to replace the backing
          service with another service matching the reference criteria. An
          application may be notified of a change in backing service by
          registering a <literal>listener</literal>. If no matching service is
          available, then the <literal>reference</literal> is said to be
          <emphasis>unsatisfied</emphasis>. An unsatisfied mandatory service
          causes any exported service (<literal>service</literal> bean) that
          depends on it to be unregistered from the service registry until
          such time as the reference is satisfied again.</para>

          <para>When an operation is invoked on an unsatisfied
          <literal>reference</literal> bean (either optional or mandatory),
          the invocation blocks until the reference becomes satisfied. The
          optional <literal>timeout</literal> attribute of the
          <literal>reference</literal> element enables a timeout value (in
          milliseconds) to be specified. If a timeout value is specified and
          no matching service becomes available within the timeout period, an
          unchecked <literal>ServiceUnavailableException</literal> is
          thrown.</para>

          <para>When using the <literal>osgi</literal> element to enclose
          <literal>service</literal> and <literal>reference</literal>
          elements, the <literal>default-timeout</literal> attribute may be
          used to specify a default timeout (in milliseconds) for all
          reference elements that do not explicitly specify one. For
          example:</para>

          <screen>&lt;beans:beans osgi:default-timeout="5000"&gt;

  &lt;!-- we will wait up to 5 seconds for a matching service on
       invocation --&gt;
  &lt;reference id="someService" interface="com.xyz.AService"/&gt;

  &lt;!-- we will wait only 1 second for a matching service on 
       invocation --&gt;
  &lt;reference id="someOtherService" interface="com.xyz.BService"
       timeout="1000"/&gt;

&lt;/beans:beans&gt;</screen>

          <para>For applications that need to be aware of when the service
          backing a <literal>reference</literal> bean is bound and unbound, it
          is possible to register one or more listeners using the nested
          <literal>listener</literal> element. The <literal>listener</literal>
          element refers to a bean (either by name, or by defining one inline)
          that will receive bind and unbind notifications. If this bean
          implements Spring's
          <literal>org.springframework.osgi.service.TargetSourceLifecycleListener</literal>
          interface, then the <literal>bind</literal> and
          <literal>unbind</literal> operations in this interface will be
          invoked. Instead of implementing this interface (or in addition),
          custom bind and unbind callback methods may be named.</para>

          <para>An example of declaring a listener that implements
          <literal>TargetSourceLifecycleListener</literal>:</para>

          <screen>&lt;reference id="someService" interface="com.xyz.MessageService"&gt;
  &lt;listener ref="aListenerBean"/&gt;
&lt;/reference&gt;</screen>

          <para>An example of declaring an inline listener bean with custom
          bind and unbind methods:</para>

          <screen>&lt;reference id="someService" interface="com.xyz.MessageService"&gt;
  &lt;listener bind-method="onBind" unbind-method="onUnbind"&gt;
     &lt;beans:bean class="MyCustomListener"/&gt;
  &lt;/listener&gt;
&lt;/reference&gt;</screen>

          <para>If the listener bean implements the
          <literal>TargetSourceLifecyleListener</literal> interface
          <emphasis>and</emphasis> the listener definition specifies custom
          bind and unbind operations then both the
          <literal>TargetSourceLifecycleListener</literal> operation and the
          custom operation will be invoked, in that order.</para>

          <para>The signature of a custom bind or unbind method must be one
          of:</para>

          <screen>public void anyMethodName(ServiceType service, Dictionary properties);

public void anyMethodName(ServiceType service, Map properties);

public void anyMethodName(ServiceReference ref);</screen>

          <para>If the method signature has a single argument of type
          <literal>ServiceReference</literal> then the
          <literal>ServiceReference</literal> of the service will be passed to
          the callback in place of the service object itself.</para>

          <para>where <literal>ServiceType</literal> can be any type that is
          assignable from the <literal>reference</literal> interface type. The
          properties parameter contains the set of properties that the service
          was registered with.</para>

          <para>A bind callback is invoked when the reference is initially
          bound to a backing service, and whenever the backing service is
          replaced by a new backing service.</para>

          <para>An unbind callback is only invoked when the current backing
          service is unregistered, and no replacement service is immediately
          available (i.e., the <literal>reference</literal> becomes
          unsatisfied).</para>

          <para>Bind and unbind callbacks are made synchronously as part of
          processing an OSGi <literal>serviceChanged</literal> event for the
          backing OSGi service, and are invoked on the OSGi thread that
          delivers the corresponding OSGi
          <literal>ServiceEvent</literal>.</para>
        </section>
      </section>

      <section id="service-registry:refs:multi">
        <title>Referencing collections of services</title>

        <para>Sometimes an application needs access not simply to any service
        meeting some criteria, but to <emphasis>all</emphasis> services
        meeting some criteria. The matching services may be held in a
        <literal>List</literal> or <literal>Set</literal> (optionally
        sorted).</para>

        <para>The difference between using a <literal>List</literal> and a
        <literal>Set</literal> to manage the collection is one of equality.
        Two or more services published in the registry (and with distinct
        service ids) may be "equal" to each other, depending on the
        implementation of equals used by the service implementations. Only one
        such service will be present in a set, whereas all services returned
        from the registry will be present in a list.</para>

        <para>The <literal>set</literal> and <literal>list</literal> elements
        are used to define collections of services with set or list semantics
        respectively.</para>

        <para>These elements support the attributes
        <literal>interface</literal>, <literal>filter</literal>,
        <literal>bean-name</literal>, <literal>cardinality</literal>, and
        <literal>context-class-loader</literal>, with the same semantics as for
        the <literal>reference</literal> element. The allowable values for the
        <literal>cardinality</literal> attribute are <literal>0..n</literal>
        and <literal>1..n</literal>. A cardinality value of
        <literal>0..n</literal> indicates that it is permissible for their to
        be no matching services. A cardinality value of
        <literal>1..n</literal> indicates that at least one matching service
        is required at all times. Such a reference is considered a
        <emphasis>mandatory</emphasis> reference and any exported services
        from the same bundle (<literal>service</literal> defined beans) that
        depend on a mandatory reference will automatically be unregistered
        when the reference becomes unsatisfied, and reregistered when the
        reference becomes satisfied again.</para>

        <para>The bean defined by a <literal>list</literal> element is of type
        <literal>java.util.List</literal>. The bean defined by a
        <literal>set</literal> element is of type
        <literal>java.util.Set</literal>.</para>

        <para>The following example defines a bean of type List that will
        contain all registered services supporting the
        <literal>EventListener</literal> interface:</para>

        <screen>&lt;list id="myEventListeners" 
  interface="com.xyz.EventListener"/&gt;</screen>

        <para>The members of the collection defined by the bean are managed
        dynamically by Spring. As matching services are registered and
        unregistered in the service registry, the collection membership will
        be kept up to date. Each member of the collection supports the service
        interfaces that the corresponding service was registered with and that
        are visible to the bundle.</para>

        <para>It is possible to specify a sorting order using either the
        <literal>comparator-ref</literal> attribute, or the nested
        <literal>comparator</literal> element. The
        <literal>comparator-ref</literal> attribute is used to refer to a
        named bean implementing <literal>java.util.Comparator</literal>. The
        <literal>comparator</literal> element can be used to define an inline
        bean. For example:</para>

        <screen>&lt;set id="myServices" interface="com.xyz.MyService"
  comparator-ref="someComparator"/&gt;

&lt;list id="myOtherServices" 
  interface="com.xyz.OtherService"&gt;
  &lt;comparator&gt;
     &lt;beans:bean class="MyOtherServiceComparator"/&gt;
  &lt;/comparator&gt;
&lt;/list&gt;</screen>

        <para>To sort using a natural ordering instead of an explicit
        comparator, you can use the <literal>natural-ordering</literal>
        element inside of <literal>comparator</literal>. You need to specify
        the basis for the natural ordering: based on the service references,
        following the <literal>ServiceReference</literal> natural ordering
        defined in the OSGi Core Specification section 6.1.2.3; or based on
        the services themselves (in which case the services must be
        <literal>Comparable</literal>).</para>

        <screen>&lt;list id="myServices" interface"com.xyz.MyService"&gt;
  &lt;comparator&gt;&lt;natural-ordering basis="services"/&gt;&lt;/comparator&gt;
&lt;/list&gt;

&lt;set id="myOtherServices"interface="com.xyz.OtherService"&gt;
  &lt;comparator&gt;&lt;natural-ordering basis="service-references"/&gt;&lt;/comparator&gt;
&lt;/set&gt;</screen>

        <para></para>

        <para>When iterating over the collection, the semantics of
        <literal>Iterator</literal> are guaranteed to be observed (if
        <literal>hasNext()</literal> returns true, then
        <literal>next()</literal> will return a service, if
        <literal>hasNext()</literal> returns false then
        <literal>next()</literal> will throw an exception.). In addition any
        elements added to the collection during iteration over a sorted
        collection will only be visible if the iterator has not already passed
        their sort point.</para>

        <section id="service-registry:refs:multi:dynamics">
          <title>Dealing with Service dynamics</title>

          <para>Collection membership is automatically managed as matching
          services are registered or unregistered. The nested
          <literal>listener</literal> element is supported with all of the
          reference collection beans. The bind callback is invoked whenever a
          service is added to the collection, and the unbind callback is
          invoked whenever a service is removed from the collection.</para>

          <para>When iterating over the members of a collection, it is always
          possible that the service backing a collection member is
          unregistered after it has been returned from an invocation of
          <literal>Iterator.next()</literal>. If an operation is invoked on
          such a service, a <literal>ServiceUnavailableException</literal>
          will be thrown.</para>
        </section>
      </section>
    </section>
  </chapter>
