<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
                 "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<appendix id="appendix-roadmap">
	<title>Roadmap</title>

	<para>
		This appendix documents features on the Spring Dynamic Modules
		roadmap. The design of these features specified here is subject
		to change. As a most up to date source, please see
		<ulink url="http://jira.springframework.org/browse/OSGI">
			our
		</ulink>
		issue tracker.
	</para>

	<section>
		<title>Enhanced Configuration Admin Support</title>

		<section>
			<title>Managed Services</title>

			<para>
				It should be possible to easily instantiate a bean from the configuration information stored for a
				<literal>ManagedService</literal>, and a set of beans from the configuration information
				stored for a <literal>ManagedServiceFactory</literal>. In addition, updates to the configuration information
				should be propagated to beans created in this way.
			</para>

			<para>
				The
				<literal>managed-service</literal>	element is used to define a bean based on the configuration information stored under a given
				persistent id. It has two mandatory attributes, <literal>class</literal> and <literal>persistent-id</literal>. The
				<literal>persistent-id</literal> attribute is used to specify the persistent id to be looked up in the configuration administration service,
				<literal>class</literal> indicates the Java class of the bean that will be	instantiated.
			</para>

			<para>A simple declaration of a managed service bean would look as follows:</para>

			<programlisting><![CDATA[<osgix:managed-service id="myService" class="com.xyz.MessageService" 
   persistent-id="com.xyz.messageservice"/>]]></programlisting>

        <para>The properties of the <literal>managed-service</literal> bean
        are autowired by name based on the configuration found under the given
        persistent id. It is possible to declare regular Spring bean
        <literal>property</literal> elements within the
        <literal>managed-service</literal> declaration. If a property value is
        defined both in the configuration object stored in the Configuration
        Admin service, and in a nested <literal>property</literal> element,
        then the value from Configuration Admin takes precedence. Property
        values specified via <literal>property</literal> elements can
        therefore be treated as default values to be used if none is available
        through Configuration Admin.</para>

        <para>It is possible for the configuration data stored in
        Configuration Admin to be updated once the bean has been created. By
        default, any updates post-creation will be ignored. To receive
        configuration updates, the <literal>update-strategy</literal>
        attribute can be used with a value of either
        <literal>bean-managed</literal> or
        <literal>container-managed</literal>.</para>

        <para>The default value of the optional
        <literal>update-strategy</literal> attribute is
        <literal>none</literal>. If an update strategy of
        <literal>bean-managed</literal> is specified then the
        <literal>update-method</literal> attribute must also be used to
        specify the name of a method defined on the bean class that will be
        invoked if the configuration for the bean is updated. The update
        method must have one of the following signatures:</para>

        <programlisting language="java"><![CDATA[public void anyMethodName(Map properties)
public void anyMethodName(Map<String,?> properties); // for Java 5
public void anyMethodName(Dictionary properties);]]></programlisting>

        <para>When an update strategy of <literal>container-managed</literal>
        is specified then the container will autowire the bean instance by
        name based on the new properties received in the update. For
        <literal>container-managed</literal> updates, the bean class must
        provide setter methods for the bean properties that it wishes to have
        updated. Container-managed updates cannot be used in conjunction with
        constructor injection. Before proceeding to autowire based on the new
        property values, a lock is taken on the bean instance. This lock is
        released once autowiring has completed. A class may therefore
        synchronize its service methods or otherwise lock on the bean instance
        in order to have atomic update semantics.</para>
      </section>

      <section>
        <title>Managed Service Factories</title>

        <para>The <literal>managed-service-factory</literal> element is
        similar to the <literal>managed-service</literal> element, but instead
        defines a set of beans, one instance for each configuration stored
        under the given factory pid. It has two mandatory attributes,
        <literal>factory-pid</literal> and <literal>class</literal>.</para>

        <para>A simple <literal>managed-service-factory</literal> declaration
        would look as follows:</para>

        <programlisting><![CDATA[<osgix:managed-service-factory id="someId" factory-pid="org.xzy.services" 
           class="MyServiceClass"/>]]></programlisting>

        <para>This declaration results in the creation of zero or more beans,
        one bean for each configuration registered under the given factory
        pid. The beans will have synthetic names generated by appending "-"
        followed by the persistent id of the configuration object as returned
        by Configuration Admin, to the value of the <literal>id</literal>
        attribute used in the declaration of the
        <literal>managed-service-factory</literal>. For example,
        <literal>someId-config.admin.generated.pid</literal>.</para>

        <para>Over time new configuration objects may be added under the
        factory pid. A new bean instance is automatically instantiated
        whenever a new configuration object is created. If a configuration
        object stored under the factory pid is deleted, then the corresponding
        bean instance will be disposed (this includes driving the
        <literal>DisposableBean</literal> callback if the bean implements
        <literal>DisposableBean</literal>). The option
        <literal>destroy-method</literal> attribute of the
        <literal>managed-service-factory</literal> element may be used to
        specify a destroy callback to be invoked on the bean instance. Such a
        method must have a signature:</para>

        <programlisting language="java"><![CDATA[public void anyMethodName();]]></programlisting>

        <para>It is also possible for the configuration of an existing bean to
        be updated. The same <literal>update-strategy</literal> and
        <literal>update-method</literal> attributes are available as for the
        <literal>managed-service</literal> element and with the same semantics
        (though obviously only the bean instance whose configuration has been
        updated in Configuration Admin will actually be updated). The same
        client-locking semantics also apply when using the
        <literal>container-managed</literal> update strategy</para>
      </section>

      <section>
        <title>Direct access to configuration data</title>

        <para>If you need to work directly with the configuration data stored
        under a given persistent id or factory persistent id, the easiest way
        to do this is to register a service that implements either the
        <literal>ManagedService</literal> or
        <literal>ManagedServiceFactory</literal> interface and specify the pid
        that you are interested in as a service property. For example:</para>

        <programlisting><![CDATA[<service interface="org.osgi.service.cm.ManagedService" ref="MyManagedService">
  <service-properties>
    <entry key="service.pid" value="my.managed.service.pid"/>
  </service-properties>
</service>

<bean id="myManagedService" class="com.xyz.MyManagedService"/>]]></programlisting>

        <para>and where the class <literal>MyManagedService</literal>
        implements
        <literal>org.osgi.service.cm.ManagedService</literal>.</para>
      </section>

      <section>
        <title>Publishing configuration administration properties with
        exported services</title>

        <para>We intend to provide support for automatic publication of
        service properties sourced from the Configuration Admin service under
        a given persistent id. This support has yet to be designed but may
        look as follows:</para>

        <programlisting><![CDATA[<service ref="toBeExported" interface="SomeInterface">
   <osgix:config-properties persistent-id="pid"/>
</service>]]></programlisting>

        <para>Issues to be considered are scoping of a subset of properties to
        be published (public/private), and automatic updates to published
        service properties if the value is updated via config admin.</para>

        <para>Note that named properties can easily be published as service
        properties already without this support, simply by using the
        <literal>property-placeholder</literal> support.</para>
      </section>
    </section>

    <section>
      <title>Access to Service References for Collections</title>

      <para>The current specification does not provide for access to the
      <literal>ServiceReference</literal> objects for services in a managed
      collection (i.e. obtained via a <literal>set</literal> or
      <literal>list</literal> declaration). A future release of Spring Dynamic
      Modules will provide an easy means of gaining access to these
      references.</para>
    </section>

    <section>
      <title>Start level integration</title>

      <para>A future release of Spring Dynamic Modules may offer the following
      additional guarantee with respect to application context creation and
      start levels:</para>

      <para>Application context creation happens asynchronously. However, the
      extender bundle does guarantee that the creation of all application
      contexts for bundles at start level <literal>n</literal> will be
      complete before the creation of any application context at start level
      <literal>m</literal>, where <literal>m > n</literal>. Care must
      therefore be taken not to introduce any mandatory dependencies on
      services exported by bundles with higher start levels or a deadlock will
      be introduced.</para>

      <para>In a similar vein, when shutting down the extender bundle,
      application contexts at start level <literal>m</literal> will be shut
      down before application contexts at start level <literal>n</literal>,
      where <literal>m > n</literal>.</para>
    </section>

    <section>
      <title>Web library integration</title>

      <para>While generic support for web applications is available in 1.1.0, we'd like to provide close
      integration with existing popular libraries (like JSF and Spring Web Flow) in the upcoming releases.</para>
    </section>

    <section>
      <title>ORM/Persistence support</title>

      <para>Care needs to be taken when using JPA or Hibernate under OSGi as
      the persistence engines must have visibility of the persistent types and
      mapping files. The Spring Dynamic Modules project will be investigating
      an extension model to make managing this easier when persistent
      configuration is split across several bundles. See Peter Krien's <ulink
      url="http://www.osgi.org/blog/2007/06/osgi-and-hibernate.html">blog
      entry</ulink> on the topic for an insight into the issues.</para>
      <para>Also, the project aims to simplify deployment of JDBC drivers and
      pooling libraries that at the moment require special <literal>DynamicImport-Package</literal>.</para>
    </section>

	<section>
	  <title>OSGi standards</title>
	
	  <para>While OSGi 4.0 is currently required, work is underway to take advantage of the
	  new features available in 4.1. SpringSource is an active participant in the 
	  <ulink url="http://www2.osgi.org/EEG/HomePage">OSGi Enterprise Expert Group</ulink> 
	  and we hope to help many of the ideas found in the Spring Dynamic Modules project 
	  to make their way into the OSGi R5 specification.
	  Spring Dynamic Modules would obviously seek to support any such standards at that 
	  point in time.</para>
	</section>
    
</appendix>
